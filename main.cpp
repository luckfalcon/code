#include<iostream>
#include<string>
#include<map>
#include<vector>
//#include<algorithm>
//#include<stack>
// #include"bsearch_recursive.h"
// #include"insertion_sort.h"
// #include"q_sort.h"
// #include"merge_sort.h"
#include"link_list.h"
//#include"stack_queue.h"
#include"string_KMP.h"
#include"tree_map.h"
using namespace std;
//template<typename T>
// struct t_node
// {
//     T data;
//     t_node *next;
//     t_node():next(nullptr){}
// };
// template<typename T>
// class llist
// {
//     public:
//     llist():head(new t_node<T>),cnt(0){}
//     void create(t_node<T>**, const std::initializer_list<T>&,int,int);
//     void create(const std::initializer_list<T>&ls)
//     {
//         t_node<T> *p = head;
//         create(&p->next,ls,0,ls.size());
//     }
//     void print();
//     bool empty(){return (head->next==nullptr);}
//     private:
//     t_node<T>*head;
//     int cnt;

// };
// template<typename T>
// void llist<T>::create(t_node<T>**t, const std::initializer_list<T>&ls,int left,int right)
// {
//     if(left==right)
//     {
//         return;
//     }
//     auto beg=ls.begin();
//     *t=new t_node<T>;
//     (*t)->data=*(beg+left);
//     ++left;
//     ++cnt;
//     create(&(*t)->next,ls,left,right);
// }
// template<typename T>
// void llist<T>::print()
// {
//     t_node<T>*p=head->next;
//     if(!p)
//     {
//         std::cout<<"empty list"<<std::endl;
//     }
//     while(p)
//     {
//         //std::cout<<cnt<<std::endl;
//         std::cout<<p->data<<std::endl;
//         p=p->next;
//     }
// }
int main()
{

    //int arr[]={9,4,3,7,1,8,5,2,6};
    //insertion_sort<int>(arr);
    //cout<<"pivot index: "<<qs_partion<int>(arr)<<endl;
    //q_sort<int>(arr);
    // merge_sort<int>(arr);
    // print_arr<int>(arr);
    //cout<<bsearch_recursive(arr,8)<<endl;
   
    
   

    return 0;
}